Implementation of the Refyre Spec:

refyre will be designed with a focus on atomic building blocks that can be used to power most
of the complex operations and workhorses necessary 

Here are the "BIG 5" operations that'll define refyre:

CONSTRUCT: Creates a refyre file graph representing the refyre spec.
    - Doesn't consider whether the file graph actually exists. It's goal is to purely make the constructs refyre needs

    - Uses a two step process:
        1. Lexer: Processes the file, and boils it down into an array of information nodes
        2. Parser: Takes the information and constructs the file graph out of it

VERIFY: Verifies whether an input refyre graph exists
    - Note that the goal of verify isn't to check if the actual content exists; it's merely to make sure the file directories are valid 

ACTIVATE: Populates a graph that is assumed to be previously verified
    - Verification of the file graph will NOT be done during the ACTIVATE method 

    - "Populates" has two meanings here:
        1. Populating all the filepaths in the clusters
        2. APPENDING / ACCUMULATING all the new variables created
            - Why append rather than define? This enables consecutive activation, i.e multiple graphs can be simultaneously activated and their variables accumulate
        
OUTPUT: Takes an output file graph, and does an in-place generation of the file graph

CLEAR: Cleans out a refyre instance

From these five core building blocks, we can make more complex operations

For example, consider the following implementation of refactor:

    refactor(I, O):
    '''
    I - list of filepaths for input specs
    O - list of filepaths for input specs
    '''

    for inp in I:
        G_i <-- construct(inp)
        if verify(G_i):
            activate(G_i)
        
    for oup in O:
        G_i <-- construct(oup)
        output(G_i)

Questions about implementation:

